{
    "sourceFile": "service/userservice.go",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 11,
            "patches": [
                {
                    "date": 1691484401693,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1691484634119,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,162 @@\n+// 后缀类型为go\r\n+// 1. Register函数中，密码长度校验应该放在校验用户名是否存在之前\r\n+// 2. Register函数中，加密后的密码应该使用字节数组类型，而不是字符串类型\r\n+// 3. Login函数中，查找用户时应该使用GetUserByName函数，而不是GetUserById函数\r\n+// 4. GetUserInfo函数中，应该判断查找到的用户是否为nil，如果为nil则返回错误\r\n+// 5. GenerateToken函数中，应该将jwtKey定义为常量，而不是变量\r\n+// 6. VerifyToken函数中，应该将jwtKey定义为常量，而不是变量\r\n+// 问题：缺少注释，不易于阅读和维护。\r\n+// 问题：缺少注释，不易于阅读和维护。\r\n+package service\r\n+\r\n+import (\r\n+\t\"errors\"\r\n+\t\"fmt\"\r\n+\t\"time\"\r\n+\r\n+\t\"github.com/Coreychen4444/Users/model\"\r\n+\t\"github.com/Coreychen4444/Users/repository\"\r\n+\t\"github.com/dgrijalva/jwt-go\"\r\n+\t\"golang.org/x/crypto/bcrypt\"\r\n+\t\"gorm.io/gorm\"\r\n+)\r\n+\r\n+type UserService struct {\r\n+\tr *repository.DbRepository\r\n+}\r\n+\r\n+func NewUserService(r *repository.DbRepository) *UserService {\r\n+\treturn &UserService{r: r}\r\n+}\r\n+\r\n+// 注册\r\n+func (s *UserService) Register(username, password string) (*model.User, string, error) {\r\n+\t//校验\r\n+\tif len(username) == 0 || len(password) == 0 {\r\n+\t\treturn nil, \"\", errors.New(\"用户名或密码不能为空,请重新输入\")\r\n+\t}\r\n+\tif len(password) < 6 {\r\n+\t\treturn nil, \"\", errors.New(\"密码长度不能小于6位,请重新输入\")\r\n+\t}\r\n+\tif len(username) > 32 || len(password) > 32 {\r\n+\t\treturn nil, \"\", errors.New(\"用户名或密码长度不能超过32位,请重新输入\")\r\n+\t}\r\n+\tuser, err := s.r.GetUserByName(username)\r\n+\tif err != nil {\r\n+\t\treturn nil, \"\", err\r\n+\t}\r\n+\t//判断用户名是否存在\r\n+\tif user != nil {\r\n+\t\treturn nil, \"\", errors.New(\"用户名已存在,请重新输入\")\r\n+\t}\r\n+\tvar newUser model.User\r\n+\t//加密\r\n+\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\r\n+\tif err != nil {\r\n+\t\treturn nil, \"\", err\r\n+\t}\r\n+\tnewUser.Username = username\r\n+\tnewUser.PasswordHash = string(hashedPassword)\r\n+\t//创建用户\r\n+\tuser, err = s.r.CreateUsers(&newUser)\r\n+\tif err != nil {\r\n+\t\treturn nil, \"\", err\r\n+\t}\r\n+\ttoken, tknerr := GenerateToken(user.ID)\r\n+\tif tknerr != nil {\r\n+\t\treturn nil, \"\", fmt.Errorf(\"生成token时出错: %w\", tknerr)\r\n+\t}\r\n+\treturn user, token, nil\r\n+}\r\n+\r\n+// 登录\r\n+func (s *UserService) Login(username, password string) (*model.User, string, error) {\r\n+\t//校验输入\r\n+\tif len(username) == 0 || len(password) == 0 {\r\n+\t\treturn nil, \"\", fmt.Errorf(\"用户名或密码不能为空,请重新输入\")\r\n+\t}\r\n+\tif len(username) > 32 || len(password) > 32 {\r\n+\t\treturn nil, \"\", fmt.Errorf(\"用户名或密码长度不能超过32位,请重新输入\")\r\n+\t}\r\n+\t//查找用户\r\n+\tuser, err := s.r.GetUserByName(username)\r\n+\tif err != nil {\r\n+\t\tif err == gorm.ErrRecordNotFound {\r\n+\t\t\treturn nil, \"\", fmt.Errorf(\"用户名不存在,请重新输入\")\r\n+\t\t}\r\n+\t\treturn nil, \"\", fmt.Errorf(\"查找用户时出错: %w\", err)\r\n+\t}\r\n+\t//验证密码\r\n+\terr = bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password))\r\n+\tif err != nil {\r\n+\t\tif err == bcrypt.ErrMismatchedHashAndPassword {\r\n+\t\t\treturn nil, \"\", fmt.Errorf(\"密码错误,请重新输入\")\r\n+\t\t}\r\n+\t\treturn nil, \"\", fmt.Errorf(\"验证密码时出错: %w\", err)\r\n+\t}\r\n+\ttoken, tknerr := GenerateToken(user.ID)\r\n+\tif tknerr != nil {\r\n+\t\treturn nil, \"\", fmt.Errorf(\"生成token时出错: %w\", tknerr)\r\n+\t}\r\n+\treturn user, token, nil\r\n+}\r\n+\r\n+// 获取用户信息\r\n+func (s *UserService) GetUserInfo(id int64, token string) (*model.User, error) {\r\n+\t_, err := VerifyToken(token)\r\n+\tif err != nil {\r\n+\t\treturn nil, fmt.Errorf(\"验证token时出错: %w\", err)\r\n+\t}\r\n+\tuser, err := s.r.GetUserById(id)\r\n+\tif err != nil {\r\n+\t\tif err == gorm.ErrRecordNotFound {\r\n+\t\t\treturn nil, fmt.Errorf(\"该用户不存在\")\r\n+\t\t}\r\n+\t\treturn nil, fmt.Errorf(\"查找用户时出错: %w\", err)\r\n+\t}\r\n+\treturn user, nil\r\n+\r\n+}\r\n+\r\n+// 生成和验证token\r\n+type Claims struct {\r\n+\tUserID int64\r\n+\tjwt.StandardClaims\r\n+}\r\n+\r\n+var jwtKey = []byte(\"tokenkey\")\r\n+\r\n+// 生成token\r\n+func GenerateToken(id int64) (string, error) {\r\n+\texpirationTime := time.Now().Add(24 * time.Hour)\r\n+\tclaims := &Claims{\r\n+\t\tUserID: id,\r\n+\t\tStandardClaims: jwt.StandardClaims{\r\n+\t\t\tExpiresAt: expirationTime.Unix(),\r\n+\t\t},\r\n+\t}\r\n+\r\n+\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\r\n+\treturn token.SignedString(jwtKey)\r\n+}\r\n+\r\n+// 验证token\r\n+func VerifyToken(tknStr string) (*Claims, error) {\r\n+\tclaims := &Claims{}\r\n+\ttkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {\r\n+\t\treturn jwtKey, nil\r\n+\t})\r\n+\r\n+\tif err != nil {\r\n+\t\tif err == jwt.ErrSignatureInvalid {\r\n+\t\t\treturn nil, fmt.Errorf(\"invalid JWT signature\")\r\n+\t\t}\r\n+\t\treturn nil, fmt.Errorf(\"could not parse JWT token\")\r\n+\t}\r\n+\r\n+\tif !tkn.Valid {\r\n+\t\treturn nil, fmt.Errorf(\"invalid JWT token\")\r\n+\t}\r\n+\r\n+\treturn claims, nil\r\n+}\r\n"
                },
                {
                    "date": 1691484991403,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,167 +1,5 @@\n-// 后缀类型为go\r\n-// 1. Register函数中，密码长度校验应该放在校验用户名是否存在之前\r\n-// 2. Register函数中，加密后的密码应该使用字节数组类型，而不是字符串类型\r\n-// 3. Login函数中，查找用户时应该使用GetUserByName函数，而不是GetUserById函数\r\n-// 4. GetUserInfo函数中，应该判断查找到的用户是否为nil，如果为nil则返回错误\r\n-// 5. GenerateToken函数中，应该将jwtKey定义为常量，而不是变量\r\n-// 6. VerifyToken函数中，应该将jwtKey定义为常量，而不是变量\r\n-// 问题：缺少注释，不易于阅读和维护。\r\n-// 问题：缺少注释，不易于阅读和维护。\r\n-package service\r\n \r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-\r\n-\t\"github.com/Coreychen4444/Users/model\"\r\n-\t\"github.com/Coreychen4444/Users/repository\"\r\n-\t\"github.com/dgrijalva/jwt-go\"\r\n-\t\"golang.org/x/crypto/bcrypt\"\r\n-\t\"gorm.io/gorm\"\r\n-)\r\n-\r\n-type UserService struct {\r\n-\tr *repository.DbRepository\r\n-}\r\n-\r\n-func NewUserService(r *repository.DbRepository) *UserService {\r\n-\treturn &UserService{r: r}\r\n-}\r\n-\r\n-// 注册\r\n-func (s *UserService) Register(username, password string) (*model.User, string, error) {\r\n-\t//校验\r\n-\tif len(username) == 0 || len(password) == 0 {\r\n-\t\treturn nil, \"\", errors.New(\"用户名或密码不能为空,请重新输入\")\r\n-\t}\r\n-\tif len(password) < 6 {\r\n-\t\treturn nil, \"\", errors.New(\"密码长度不能小于6位,请重新输入\")\r\n-\t}\r\n-\tif len(username) > 32 || len(password) > 32 {\r\n-\t\treturn nil, \"\", errors.New(\"用户名或密码长度不能超过32位,请重新输入\")\r\n-\t}\r\n-\tuser, err := s.r.GetUserByName(username)\r\n-\tif err != nil {\r\n-\t\treturn nil, \"\", err\r\n-\t}\r\n-\t//判断用户名是否存在\r\n-\tif user != nil {\r\n-\t\treturn nil, \"\", errors.New(\"用户名已存在,请重新输入\")\r\n-\t}\r\n-\tvar newUser model.User\r\n-\t//加密\r\n-\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\r\n-\tif err != nil {\r\n-\t\treturn nil, \"\", err\r\n-\t}\r\n-\tnewUser.Username = username\r\n-\tnewUser.PasswordHash = string(hashedPassword)\r\n-\t//创建用户\r\n-\tuser, err = s.r.CreateUsers(&newUser)\r\n-\tif err != nil {\r\n-\t\treturn nil, \"\", err\r\n-\t}\r\n-\ttoken, tknerr := GenerateToken(user.ID)\r\n-\tif tknerr != nil {\r\n-\t\treturn nil, \"\", fmt.Errorf(\"生成token时出错: %w\", tknerr)\r\n-\t}\r\n-\treturn user, token, nil\r\n-}\r\n-\r\n-// 登录\r\n-func (s *UserService) Login(username, password string) (*model.User, string, error) {\r\n-\t//校验输入\r\n-\tif len(username) == 0 || len(password) == 0 {\r\n-\t\treturn nil, \"\", fmt.Errorf(\"用户名或密码不能为空,请重新输入\")\r\n-\t}\r\n-\tif len(username) > 32 || len(password) > 32 {\r\n-\t\treturn nil, \"\", fmt.Errorf(\"用户名或密码长度不能超过32位,请重新输入\")\r\n-\t}\r\n-\t//查找用户\r\n-\tuser, err := s.r.GetUserByName(username)\r\n-\tif err != nil {\r\n-\t\tif err == gorm.ErrRecordNotFound {\r\n-\t\t\treturn nil, \"\", fmt.Errorf(\"用户名不存在,请重新输入\")\r\n-\t\t}\r\n-\t\treturn nil, \"\", fmt.Errorf(\"查找用户时出错: %w\", err)\r\n-\t}\r\n-\t//验证密码\r\n-\terr = bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password))\r\n-\tif err != nil {\r\n-\t\tif err == bcrypt.ErrMismatchedHashAndPassword {\r\n-\t\t\treturn nil, \"\", fmt.Errorf(\"密码错误,请重新输入\")\r\n-\t\t}\r\n-\t\treturn nil, \"\", fmt.Errorf(\"验证密码时出错: %w\", err)\r\n-\t}\r\n-\ttoken, tknerr := GenerateToken(user.ID)\r\n-\tif tknerr != nil {\r\n-\t\treturn nil, \"\", fmt.Errorf(\"生成token时出错: %w\", tknerr)\r\n-\t}\r\n-\treturn user, token, nil\r\n-}\r\n-\r\n-// 获取用户信息\r\n-func (s *UserService) GetUserInfo(id int64, token string) (*model.User, error) {\r\n-\t_, err := VerifyToken(token)\r\n-\tif err != nil {\r\n-\t\treturn nil, fmt.Errorf(\"验证token时出错: %w\", err)\r\n-\t}\r\n-\tuser, err := s.r.GetUserById(id)\r\n-\tif err != nil {\r\n-\t\tif err == gorm.ErrRecordNotFound {\r\n-\t\t\treturn nil, fmt.Errorf(\"该用户不存在\")\r\n-\t\t}\r\n-\t\treturn nil, fmt.Errorf(\"查找用户时出错: %w\", err)\r\n-\t}\r\n-\treturn user, nil\r\n-\r\n-}\r\n-\r\n-// 生成和验证token\r\n-type Claims struct {\r\n-\tUserID int64\r\n-\tjwt.StandardClaims\r\n-}\r\n-\r\n-var jwtKey = []byte(\"tokenkey\")\r\n-\r\n-// 生成token\r\n-func GenerateToken(id int64) (string, error) {\r\n-\texpirationTime := time.Now().Add(24 * time.Hour)\r\n-\tclaims := &Claims{\r\n-\t\tUserID: id,\r\n-\t\tStandardClaims: jwt.StandardClaims{\r\n-\t\t\tExpiresAt: expirationTime.Unix(),\r\n-\t\t},\r\n-\t}\r\n-\r\n-\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\r\n-\treturn token.SignedString(jwtKey)\r\n-}\r\n-\r\n-// 验证token\r\n-func VerifyToken(tknStr string) (*Claims, error) {\r\n-\tclaims := &Claims{}\r\n-\ttkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {\r\n-\t\treturn jwtKey, nil\r\n-\t})\r\n-\r\n-\tif err != nil {\r\n-\t\tif err == jwt.ErrSignatureInvalid {\r\n-\t\t\treturn nil, fmt.Errorf(\"invalid JWT signature\")\r\n-\t\t}\r\n-\t\treturn nil, fmt.Errorf(\"could not parse JWT token\")\r\n-\t}\r\n-\r\n-\tif !tkn.Valid {\r\n-\t\treturn nil, fmt.Errorf(\"invalid JWT token\")\r\n-\t}\r\n-\r\n-\treturn claims, nil\r\n-}\r\n-// 问题：缺少注释，不易于阅读和维护。\r\n package service\r\n \r\n import (\r\n \t\"errors\"\r\n"
                },
                {
                    "date": 1691491007757,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,4 @@\n-\r\n package service\r\n \r\n import (\r\n \t\"errors\"\r\n@@ -151,4 +150,15 @@\n \t}\r\n \r\n \treturn claims, nil\r\n }\r\n+func (s *UserService) Init() error {\r\n+    // 初始化一个固定的用户作为演示用\r\n+    username := \"demo\"\r\n+    password := \"password123\"\r\n+    user, _, err := s.Register(username, password)\r\n+    if err != nil {\r\n+        return err\r\n+    }\r\n+    fmt.Printf(\"Demo user registered with ID: %d\\n\", user.ID)\r\n+    return nil\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691492966624,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,8 +21,13 @@\n }\r\n \r\n // 注册\r\n func (s *UserService) Register(username, password string) (*model.User, string, error) {\r\n+\tuser, err := s.r.CreateUsers(&newUser)\r\n+    if err != nil {\r\n+        fmt.Println(\"Error creating user:\", err)\r\n+        return nil, \"\", err\r\n+    }\r\n \t//校验\r\n \tif len(username) == 0 || len(password) == 0 {\r\n \t\treturn nil, \"\", errors.New(\"用户名或密码不能为空,请重新输入\")\r\n \t}\r\n"
                },
                {
                    "date": 1691492980006,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,13 +21,9 @@\n }\r\n \r\n // 注册\r\n func (s *UserService) Register(username, password string) (*model.User, string, error) {\r\n-\tuser, err := s.r.CreateUsers(&newUser)\r\n-    if err != nil {\r\n-        fmt.Println(\"Error creating user:\", err)\r\n-        return nil, \"\", err\r\n-    }\r\n+\t\r\n \t//校验\r\n \tif len(username) == 0 || len(password) == 0 {\r\n \t\treturn nil, \"\", errors.New(\"用户名或密码不能为空,请重新输入\")\r\n \t}\r\n"
                },
                {
                    "date": 1691494294430,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,164 @@\n+package service\r\n+\r\n+import (\r\n+\t\"errors\"\r\n+\t\"fmt\"\r\n+\t\"time\"\r\n+\r\n+\t\"github.com/Coreychen4444/Users/model\"\r\n+\t\"github.com/Coreychen4444/Users/repository\"\r\n+\t\"github.com/dgrijalva/jwt-go\"\r\n+\t\"golang.org/x/crypto/bcrypt\"\r\n+\t\"gorm.io/gorm\"\r\n+)\r\n+\r\n+type UserService struct {\r\n+\tr *repository.DbRepository\r\n+}\r\n+\r\n+func NewUserService(r *repository.DbRepository) *UserService {\r\n+\treturn &UserService{r: r}\r\n+}\r\n+\r\n+// 注册\r\n+func (s *UserService) Register(username, password string) (*model.User, string, error) {\r\n+\t//校验\r\n+\tif len(username) == 0 || len(password) == 0 {\r\n+\t\treturn nil, \"\", errors.New(\"用户名或密码不能为空,请重新输入\")\r\n+\t}\r\n+\tif len(password) < 6 {\r\n+\t\treturn nil, \"\", errors.New(\"密码长度不能小于6位,请重新输入\")\r\n+\t}\r\n+\tif len(username) > 32 || len(password) > 32 {\r\n+\t\treturn nil, \"\", errors.New(\"用户名或密码长度不能超过32位,请重新输入\")\r\n+\t}\r\n+\tuser, err := s.r.GetUserByName(username)\r\n+\tif err != nil &&{\r\n+\t\treturn nil, \"\", err\r\n+\t}\r\n+\t//判断用户名是否存在\r\n+\tif user != nil {\r\n+\t\treturn nil, \"\", errors.New(\"用户名已存在,请重新输入\")\r\n+\t}\r\n+\tvar newUser model.User\r\n+\t//加密\r\n+\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\r\n+\tif err != nil {\r\n+\t\treturn nil, \"\", err\r\n+\t}\r\n+\tnewUser.Username = username\r\n+\tnewUser.PasswordHash = string(hashedPassword)\r\n+\t//创建用户\r\n+\tuser, err = s.r.CreateUsers(&newUser)\r\n+\tif err != nil {\r\n+\t\treturn nil, \"\", err\r\n+\t}\r\n+\ttoken, tknerr := GenerateToken(user.ID)\r\n+\tif tknerr != nil {\r\n+\t\treturn nil, \"\", fmt.Errorf(\"生成token时出错: %w\", tknerr)\r\n+\t}\r\n+\treturn user, token, nil\r\n+}\r\n+\r\n+// 登录\r\n+func (s *UserService) Login(username, password string) (*model.User, string, error) {\r\n+\t//校验输入\r\n+\tif len(username) == 0 || len(password) == 0 {\r\n+\t\treturn nil, \"\", fmt.Errorf(\"用户名或密码不能为空,请重新输入\")\r\n+\t}\r\n+\tif len(username) > 32 || len(password) > 32 {\r\n+\t\treturn nil, \"\", fmt.Errorf(\"用户名或密码长度不能超过32位,请重新输入\")\r\n+\t}\r\n+\t//查找用户\r\n+\tuser, err := s.r.GetUserByName(username)\r\n+\tif err != nil {\r\n+\t\tif err == gorm.ErrRecordNotFound {\r\n+\t\t\treturn nil, \"\", fmt.Errorf(\"用户名不存在,请重新输入\")\r\n+\t\t}\r\n+\t\treturn nil, \"\", fmt.Errorf(\"查找用户时出错: %w\", err)\r\n+\t}\r\n+\t//验证密码\r\n+\terr = bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password))\r\n+\tif err != nil {\r\n+\t\tif err == bcrypt.ErrMismatchedHashAndPassword {\r\n+\t\t\treturn nil, \"\", fmt.Errorf(\"密码错误,请重新输入\")\r\n+\t\t}\r\n+\t\treturn nil, \"\", fmt.Errorf(\"验证密码时出错: %w\", err)\r\n+\t}\r\n+\ttoken, tknerr := GenerateToken(user.ID)\r\n+\tif tknerr != nil {\r\n+\t\treturn nil, \"\", fmt.Errorf(\"生成token时出错: %w\", tknerr)\r\n+\t}\r\n+\treturn user, token, nil\r\n+}\r\n+\r\n+// 获取用户信息\r\n+func (s *UserService) GetUserInfo(id int64, token string) (*model.User, error) {\r\n+\t_, err := VerifyToken(token)\r\n+\tif err != nil {\r\n+\t\treturn nil, fmt.Errorf(\"验证token时出错: %w\", err)\r\n+\t}\r\n+\tuser, err := s.r.GetUserById(id)\r\n+\tif err != nil {\r\n+\t\tif err == gorm.ErrRecordNotFound {\r\n+\t\t\treturn nil, fmt.Errorf(\"该用户不存在\")\r\n+\t\t}\r\n+\t\treturn nil, fmt.Errorf(\"查找用户时出错: %w\", err)\r\n+\t}\r\n+\treturn user, nil\r\n+\r\n+}\r\n+\r\n+// 生成和验证token\r\n+type Claims struct {\r\n+\tUserID int64\r\n+\tjwt.StandardClaims\r\n+}\r\n+\r\n+var jwtKey = []byte(\"tokenkey\")\r\n+\r\n+// 生成token\r\n+func GenerateToken(id int64) (string, error) {\r\n+\texpirationTime := time.Now().Add(24 * time.Hour)\r\n+\tclaims := &Claims{\r\n+\t\tUserID: id,\r\n+\t\tStandardClaims: jwt.StandardClaims{\r\n+\t\t\tExpiresAt: expirationTime.Unix(),\r\n+\t\t},\r\n+\t}\r\n+\r\n+\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\r\n+\treturn token.SignedString(jwtKey)\r\n+}\r\n+\r\n+// 验证token\r\n+func VerifyToken(tknStr string) (*Claims, error) {\r\n+\tclaims := &Claims{}\r\n+\ttkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {\r\n+\t\treturn jwtKey, nil\r\n+\t})\r\n+\r\n+\tif err != nil {\r\n+\t\tif err == jwt.ErrSignatureInvalid {\r\n+\t\t\treturn nil, fmt.Errorf(\"invalid JWT signature\")\r\n+\t\t}\r\n+\t\treturn nil, fmt.Errorf(\"could not parse JWT token\")\r\n+\t}\r\n+\r\n+\tif !tkn.Valid {\r\n+\t\treturn nil, fmt.Errorf(\"invalid JWT token\")\r\n+\t}\r\n+\r\n+\treturn claims, nil\r\n+}\r\n+func (s *UserService) Init() error {\r\n+    // 初始化一个固定的用户作为演示用\r\n+    username := \"demo\"\r\n+    password := \"password123\"\r\n+    user, _, err := s.Register(username, password)\r\n+    if err != nil {\r\n+        return err\r\n+    }\r\n+    fmt.Printf(\"Demo user registered with ID: %d\\n\", user.ID)\r\n+    return nil\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691494303527,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n \tif len(username) > 32 || len(password) > 32 {\r\n \t\treturn nil, \"\", errors.New(\"用户名或密码长度不能超过32位,请重新输入\")\r\n \t}\r\n \tuser, err := s.r.GetUserByName(username)\r\n-\tif err != nil &&{\r\n+\tif err != nil &&err!{\r\n \t\treturn nil, \"\", err\r\n \t}\r\n \t//判断用户名是否存在\r\n \tif user != nil {\r\n@@ -160,170 +160,5 @@\n         return err\r\n     }\r\n     fmt.Printf(\"Demo user registered with ID: %d\\n\", user.ID)\r\n     return nil\r\n-}\n-package service\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-\r\n-\t\"github.com/Coreychen4444/Users/model\"\r\n-\t\"github.com/Coreychen4444/Users/repository\"\r\n-\t\"github.com/dgrijalva/jwt-go\"\r\n-\t\"golang.org/x/crypto/bcrypt\"\r\n-\t\"gorm.io/gorm\"\r\n-)\r\n-\r\n-type UserService struct {\r\n-\tr *repository.DbRepository\r\n-}\r\n-\r\n-func NewUserService(r *repository.DbRepository) *UserService {\r\n-\treturn &UserService{r: r}\r\n-}\r\n-\r\n-// 注册\r\n-func (s *UserService) Register(username, password string) (*model.User, string, error) {\r\n-\t\r\n-\t//校验\r\n-\tif len(username) == 0 || len(password) == 0 {\r\n-\t\treturn nil, \"\", errors.New(\"用户名或密码不能为空,请重新输入\")\r\n-\t}\r\n-\tif len(password) < 6 {\r\n-\t\treturn nil, \"\", errors.New(\"密码长度不能小于6位,请重新输入\")\r\n-\t}\r\n-\tif len(username) > 32 || len(password) > 32 {\r\n-\t\treturn nil, \"\", errors.New(\"用户名或密码长度不能超过32位,请重新输入\")\r\n-\t}\r\n-\tuser, err := s.r.GetUserByName(username)\r\n-\tif err != nil {\r\n-\t\treturn nil, \"\", err\r\n-\t}\r\n-\t//判断用户名是否存在\r\n-\tif user != nil {\r\n-\t\treturn nil, \"\", errors.New(\"用户名已存在,请重新输入\")\r\n-\t}\r\n-\tvar newUser model.User\r\n-\t//加密\r\n-\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\r\n-\tif err != nil {\r\n-\t\treturn nil, \"\", err\r\n-\t}\r\n-\tnewUser.Username = username\r\n-\tnewUser.PasswordHash = string(hashedPassword)\r\n-\t//创建用户\r\n-\tuser, err = s.r.CreateUsers(&newUser)\r\n-\tif err != nil {\r\n-\t\treturn nil, \"\", err\r\n-\t}\r\n-\ttoken, tknerr := GenerateToken(user.ID)\r\n-\tif tknerr != nil {\r\n-\t\treturn nil, \"\", fmt.Errorf(\"生成token时出错: %w\", tknerr)\r\n-\t}\r\n-\treturn user, token, nil\r\n-}\r\n-\r\n-// 登录\r\n-func (s *UserService) Login(username, password string) (*model.User, string, error) {\r\n-\t//校验输入\r\n-\tif len(username) == 0 || len(password) == 0 {\r\n-\t\treturn nil, \"\", fmt.Errorf(\"用户名或密码不能为空,请重新输入\")\r\n-\t}\r\n-\tif len(username) > 32 || len(password) > 32 {\r\n-\t\treturn nil, \"\", fmt.Errorf(\"用户名或密码长度不能超过32位,请重新输入\")\r\n-\t}\r\n-\t//查找用户\r\n-\tuser, err := s.r.GetUserByName(username)\r\n-\tif err != nil {\r\n-\t\tif err == gorm.ErrRecordNotFound {\r\n-\t\t\treturn nil, \"\", fmt.Errorf(\"用户名不存在,请重新输入\")\r\n-\t\t}\r\n-\t\treturn nil, \"\", fmt.Errorf(\"查找用户时出错: %w\", err)\r\n-\t}\r\n-\t//验证密码\r\n-\terr = bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password))\r\n-\tif err != nil {\r\n-\t\tif err == bcrypt.ErrMismatchedHashAndPassword {\r\n-\t\t\treturn nil, \"\", fmt.Errorf(\"密码错误,请重新输入\")\r\n-\t\t}\r\n-\t\treturn nil, \"\", fmt.Errorf(\"验证密码时出错: %w\", err)\r\n-\t}\r\n-\ttoken, tknerr := GenerateToken(user.ID)\r\n-\tif tknerr != nil {\r\n-\t\treturn nil, \"\", fmt.Errorf(\"生成token时出错: %w\", tknerr)\r\n-\t}\r\n-\treturn user, token, nil\r\n-}\r\n-\r\n-// 获取用户信息\r\n-func (s *UserService) GetUserInfo(id int64, token string) (*model.User, error) {\r\n-\t_, err := VerifyToken(token)\r\n-\tif err != nil {\r\n-\t\treturn nil, fmt.Errorf(\"验证token时出错: %w\", err)\r\n-\t}\r\n-\tuser, err := s.r.GetUserById(id)\r\n-\tif err != nil {\r\n-\t\tif err == gorm.ErrRecordNotFound {\r\n-\t\t\treturn nil, fmt.Errorf(\"该用户不存在\")\r\n-\t\t}\r\n-\t\treturn nil, fmt.Errorf(\"查找用户时出错: %w\", err)\r\n-\t}\r\n-\treturn user, nil\r\n-\r\n-}\r\n-\r\n-// 生成和验证token\r\n-type Claims struct {\r\n-\tUserID int64\r\n-\tjwt.StandardClaims\r\n-}\r\n-\r\n-var jwtKey = []byte(\"tokenkey\")\r\n-\r\n-// 生成token\r\n-func GenerateToken(id int64) (string, error) {\r\n-\texpirationTime := time.Now().Add(24 * time.Hour)\r\n-\tclaims := &Claims{\r\n-\t\tUserID: id,\r\n-\t\tStandardClaims: jwt.StandardClaims{\r\n-\t\t\tExpiresAt: expirationTime.Unix(),\r\n-\t\t},\r\n-\t}\r\n-\r\n-\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\r\n-\treturn token.SignedString(jwtKey)\r\n-}\r\n-\r\n-// 验证token\r\n-func VerifyToken(tknStr string) (*Claims, error) {\r\n-\tclaims := &Claims{}\r\n-\ttkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {\r\n-\t\treturn jwtKey, nil\r\n-\t})\r\n-\r\n-\tif err != nil {\r\n-\t\tif err == jwt.ErrSignatureInvalid {\r\n-\t\t\treturn nil, fmt.Errorf(\"invalid JWT signature\")\r\n-\t\t}\r\n-\t\treturn nil, fmt.Errorf(\"could not parse JWT token\")\r\n-\t}\r\n-\r\n-\tif !tkn.Valid {\r\n-\t\treturn nil, fmt.Errorf(\"invalid JWT token\")\r\n-\t}\r\n-\r\n-\treturn claims, nil\r\n-}\r\n-func (s *UserService) Init() error {\r\n-    // 初始化一个固定的用户作为演示用\r\n-    username := \"demo\"\r\n-    password := \"password123\"\r\n-    user, _, err := s.Register(username, password)\r\n-    if err != nil {\r\n-        return err\r\n-    }\r\n-    fmt.Printf(\"Demo user registered with ID: %d\\n\", user.ID)\r\n-    return nil\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691494309595,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n \tif len(username) > 32 || len(password) > 32 {\r\n \t\treturn nil, \"\", errors.New(\"用户名或密码长度不能超过32位,请重新输入\")\r\n \t}\r\n \tuser, err := s.r.GetUserByName(username)\r\n-\tif err != nil &&err!{\r\n+\tif err != nil &&err!=gorm{\r\n \t\treturn nil, \"\", err\r\n \t}\r\n \t//判断用户名是否存在\r\n \tif user != nil {\r\n"
                },
                {
                    "date": 1691494315429,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n \tif len(username) > 32 || len(password) > 32 {\r\n \t\treturn nil, \"\", errors.New(\"用户名或密码长度不能超过32位,请重新输入\")\r\n \t}\r\n \tuser, err := s.r.GetUserByName(username)\r\n-\tif err != nil &&err!=gorm{\r\n+\tif err != nil &&err!=gorm.R{\r\n \t\treturn nil, \"\", err\r\n \t}\r\n \t//判断用户名是否存在\r\n \tif user != nil {\r\n"
                },
                {
                    "date": 1691494321663,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,164 @@\n+package service\r\n+\r\n+import (\r\n+\t\"errors\"\r\n+\t\"fmt\"\r\n+\t\"time\"\r\n+\r\n+\t\"github.com/Coreychen4444/Users/model\"\r\n+\t\"github.com/Coreychen4444/Users/repository\"\r\n+\t\"github.com/dgrijalva/jwt-go\"\r\n+\t\"golang.org/x/crypto/bcrypt\"\r\n+\t\"gorm.io/gorm\"\r\n+)\r\n+\r\n+type UserService struct {\r\n+\tr *repository.DbRepository\r\n+}\r\n+\r\n+func NewUserService(r *repository.DbRepository) *UserService {\r\n+\treturn &UserService{r: r}\r\n+}\r\n+\r\n+// 注册\r\n+func (s *UserService) Register(username, password string) (*model.User, string, error) {\r\n+\t//校验\r\n+\tif len(username) == 0 || len(password) == 0 {\r\n+\t\treturn nil, \"\", errors.New(\"用户名或密码不能为空,请重新输入\")\r\n+\t}\r\n+\tif len(password) < 6 {\r\n+\t\treturn nil, \"\", errors.New(\"密码长度不能小于6位,请重新输入\")\r\n+\t}\r\n+\tif len(username) > 32 || len(password) > 32 {\r\n+\t\treturn nil, \"\", errors.New(\"用户名或密码长度不能超过32位,请重新输入\")\r\n+\t}\r\n+\tuser, err := s.r.GetUserByName(username)\r\n+\tif err != nil &&err!=gorm.ErrRecordNotFound{\r\n+\t\treturn nil, \"\", err\r\n+\t}\r\n+\t//判断用户名是否存在\r\n+\tif user != nil {\r\n+\t\treturn nil, \"\", errors.New(\"用户名已存在,请重新输入\")\r\n+\t}\r\n+\tvar newUser model.User\r\n+\t//加密\r\n+\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\r\n+\tif err != nil {\r\n+\t\treturn nil, \"\", err\r\n+\t}\r\n+\tnewUser.Username = username\r\n+\tnewUser.PasswordHash = string(hashedPassword)\r\n+\t//创建用户\r\n+\tuser, err = s.r.CreateUsers(&newUser)\r\n+\tif err != nil {\r\n+\t\treturn nil, \"\", err\r\n+\t}\r\n+\ttoken, tknerr := GenerateToken(user.ID)\r\n+\tif tknerr != nil {\r\n+\t\treturn nil, \"\", fmt.Errorf(\"生成token时出错: %w\", tknerr)\r\n+\t}\r\n+\treturn user, token, nil\r\n+}\r\n+\r\n+// 登录\r\n+func (s *UserService) Login(username, password string) (*model.User, string, error) {\r\n+\t//校验输入\r\n+\tif len(username) == 0 || len(password) == 0 {\r\n+\t\treturn nil, \"\", fmt.Errorf(\"用户名或密码不能为空,请重新输入\")\r\n+\t}\r\n+\tif len(username) > 32 || len(password) > 32 {\r\n+\t\treturn nil, \"\", fmt.Errorf(\"用户名或密码长度不能超过32位,请重新输入\")\r\n+\t}\r\n+\t//查找用户\r\n+\tuser, err := s.r.GetUserByName(username)\r\n+\tif err != nil {\r\n+\t\tif err == gorm.ErrRecordNotFound {\r\n+\t\t\treturn nil, \"\", fmt.Errorf(\"用户名不存在,请重新输入\")\r\n+\t\t}\r\n+\t\treturn nil, \"\", fmt.Errorf(\"查找用户时出错: %w\", err)\r\n+\t}\r\n+\t//验证密码\r\n+\terr = bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password))\r\n+\tif err != nil {\r\n+\t\tif err == bcrypt.ErrMismatchedHashAndPassword {\r\n+\t\t\treturn nil, \"\", fmt.Errorf(\"密码错误,请重新输入\")\r\n+\t\t}\r\n+\t\treturn nil, \"\", fmt.Errorf(\"验证密码时出错: %w\", err)\r\n+\t}\r\n+\ttoken, tknerr := GenerateToken(user.ID)\r\n+\tif tknerr != nil {\r\n+\t\treturn nil, \"\", fmt.Errorf(\"生成token时出错: %w\", tknerr)\r\n+\t}\r\n+\treturn user, token, nil\r\n+}\r\n+\r\n+// 获取用户信息\r\n+func (s *UserService) GetUserInfo(id int64, token string) (*model.User, error) {\r\n+\t_, err := VerifyToken(token)\r\n+\tif err != nil {\r\n+\t\treturn nil, fmt.Errorf(\"验证token时出错: %w\", err)\r\n+\t}\r\n+\tuser, err := s.r.GetUserById(id)\r\n+\tif err != nil {\r\n+\t\tif err == gorm.ErrRecordNotFound {\r\n+\t\t\treturn nil, fmt.Errorf(\"该用户不存在\")\r\n+\t\t}\r\n+\t\treturn nil, fmt.Errorf(\"查找用户时出错: %w\", err)\r\n+\t}\r\n+\treturn user, nil\r\n+\r\n+}\r\n+\r\n+// 生成和验证token\r\n+type Claims struct {\r\n+\tUserID int64\r\n+\tjwt.StandardClaims\r\n+}\r\n+\r\n+var jwtKey = []byte(\"tokenkey\")\r\n+\r\n+// 生成token\r\n+func GenerateToken(id int64) (string, error) {\r\n+\texpirationTime := time.Now().Add(24 * time.Hour)\r\n+\tclaims := &Claims{\r\n+\t\tUserID: id,\r\n+\t\tStandardClaims: jwt.StandardClaims{\r\n+\t\t\tExpiresAt: expirationTime.Unix(),\r\n+\t\t},\r\n+\t}\r\n+\r\n+\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\r\n+\treturn token.SignedString(jwtKey)\r\n+}\r\n+\r\n+// 验证token\r\n+func VerifyToken(tknStr string) (*Claims, error) {\r\n+\tclaims := &Claims{}\r\n+\ttkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {\r\n+\t\treturn jwtKey, nil\r\n+\t})\r\n+\r\n+\tif err != nil {\r\n+\t\tif err == jwt.ErrSignatureInvalid {\r\n+\t\t\treturn nil, fmt.Errorf(\"invalid JWT signature\")\r\n+\t\t}\r\n+\t\treturn nil, fmt.Errorf(\"could not parse JWT token\")\r\n+\t}\r\n+\r\n+\tif !tkn.Valid {\r\n+\t\treturn nil, fmt.Errorf(\"invalid JWT token\")\r\n+\t}\r\n+\r\n+\treturn claims, nil\r\n+}\r\n+func (s *UserService) Init() error {\r\n+    // 初始化一个固定的用户作为演示用\r\n+    username := \"demo\"\r\n+    password := \"password123\"\r\n+    user, _, err := s.Register(username, password)\r\n+    if err != nil {\r\n+        return err\r\n+    }\r\n+    fmt.Printf(\"Demo user registered with ID: %d\\n\", user.ID)\r\n+    return nil\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1691503350356,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,172 +32,8 @@\n \tif len(username) > 32 || len(password) > 32 {\r\n \t\treturn nil, \"\", errors.New(\"用户名或密码长度不能超过32位,请重新输入\")\r\n \t}\r\n \tuser, err := s.r.GetUserByName(username)\r\n-\tif err != nil &&err!=gorm.ErrRecordNotFound{\r\n-\t\treturn nil, \"\", err\r\n-\t}\r\n-\t//判断用户名是否存在\r\n-\tif user != nil {\r\n-\t\treturn nil, \"\", errors.New(\"用户名已存在,请重新输入\")\r\n-\t}\r\n-\tvar newUser model.User\r\n-\t//加密\r\n-\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\r\n-\tif err != nil {\r\n-\t\treturn nil, \"\", err\r\n-\t}\r\n-\tnewUser.Username = username\r\n-\tnewUser.PasswordHash = string(hashedPassword)\r\n-\t//创建用户\r\n-\tuser, err = s.r.CreateUsers(&newUser)\r\n-\tif err != nil {\r\n-\t\treturn nil, \"\", err\r\n-\t}\r\n-\ttoken, tknerr := GenerateToken(user.ID)\r\n-\tif tknerr != nil {\r\n-\t\treturn nil, \"\", fmt.Errorf(\"生成token时出错: %w\", tknerr)\r\n-\t}\r\n-\treturn user, token, nil\r\n-}\r\n-\r\n-// 登录\r\n-func (s *UserService) Login(username, password string) (*model.User, string, error) {\r\n-\t//校验输入\r\n-\tif len(username) == 0 || len(password) == 0 {\r\n-\t\treturn nil, \"\", fmt.Errorf(\"用户名或密码不能为空,请重新输入\")\r\n-\t}\r\n-\tif len(username) > 32 || len(password) > 32 {\r\n-\t\treturn nil, \"\", fmt.Errorf(\"用户名或密码长度不能超过32位,请重新输入\")\r\n-\t}\r\n-\t//查找用户\r\n-\tuser, err := s.r.GetUserByName(username)\r\n-\tif err != nil {\r\n-\t\tif err == gorm.ErrRecordNotFound {\r\n-\t\t\treturn nil, \"\", fmt.Errorf(\"用户名不存在,请重新输入\")\r\n-\t\t}\r\n-\t\treturn nil, \"\", fmt.Errorf(\"查找用户时出错: %w\", err)\r\n-\t}\r\n-\t//验证密码\r\n-\terr = bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password))\r\n-\tif err != nil {\r\n-\t\tif err == bcrypt.ErrMismatchedHashAndPassword {\r\n-\t\t\treturn nil, \"\", fmt.Errorf(\"密码错误,请重新输入\")\r\n-\t\t}\r\n-\t\treturn nil, \"\", fmt.Errorf(\"验证密码时出错: %w\", err)\r\n-\t}\r\n-\ttoken, tknerr := GenerateToken(user.ID)\r\n-\tif tknerr != nil {\r\n-\t\treturn nil, \"\", fmt.Errorf(\"生成token时出错: %w\", tknerr)\r\n-\t}\r\n-\treturn user, token, nil\r\n-}\r\n-\r\n-// 获取用户信息\r\n-func (s *UserService) GetUserInfo(id int64, token string) (*model.User, error) {\r\n-\t_, err := VerifyToken(token)\r\n-\tif err != nil {\r\n-\t\treturn nil, fmt.Errorf(\"验证token时出错: %w\", err)\r\n-\t}\r\n-\tuser, err := s.r.GetUserById(id)\r\n-\tif err != nil {\r\n-\t\tif err == gorm.ErrRecordNotFound {\r\n-\t\t\treturn nil, fmt.Errorf(\"该用户不存在\")\r\n-\t\t}\r\n-\t\treturn nil, fmt.Errorf(\"查找用户时出错: %w\", err)\r\n-\t}\r\n-\treturn user, nil\r\n-\r\n-}\r\n-\r\n-// 生成和验证token\r\n-type Claims struct {\r\n-\tUserID int64\r\n-\tjwt.StandardClaims\r\n-}\r\n-\r\n-var jwtKey = []byte(\"tokenkey\")\r\n-\r\n-// 生成token\r\n-func GenerateToken(id int64) (string, error) {\r\n-\texpirationTime := time.Now().Add(24 * time.Hour)\r\n-\tclaims := &Claims{\r\n-\t\tUserID: id,\r\n-\t\tStandardClaims: jwt.StandardClaims{\r\n-\t\t\tExpiresAt: expirationTime.Unix(),\r\n-\t\t},\r\n-\t}\r\n-\r\n-\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\r\n-\treturn token.SignedString(jwtKey)\r\n-}\r\n-\r\n-// 验证token\r\n-func VerifyToken(tknStr string) (*Claims, error) {\r\n-\tclaims := &Claims{}\r\n-\ttkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {\r\n-\t\treturn jwtKey, nil\r\n-\t})\r\n-\r\n-\tif err != nil {\r\n-\t\tif err == jwt.ErrSignatureInvalid {\r\n-\t\t\treturn nil, fmt.Errorf(\"invalid JWT signature\")\r\n-\t\t}\r\n-\t\treturn nil, fmt.Errorf(\"could not parse JWT token\")\r\n-\t}\r\n-\r\n-\tif !tkn.Valid {\r\n-\t\treturn nil, fmt.Errorf(\"invalid JWT token\")\r\n-\t}\r\n-\r\n-\treturn claims, nil\r\n-}\r\n-func (s *UserService) Init() error {\r\n-    // 初始化一个固定的用户作为演示用\r\n-    username := \"demo\"\r\n-    password := \"password123\"\r\n-    user, _, err := s.Register(username, password)\r\n-    if err != nil {\r\n-        return err\r\n-    }\r\n-    fmt.Printf(\"Demo user registered with ID: %d\\n\", user.ID)\r\n-    return nil\r\n-}\n-package service\r\n-\r\n-import (\r\n-\t\"errors\"\r\n-\t\"fmt\"\r\n-\t\"time\"\r\n-\r\n-\t\"github.com/Coreychen4444/Users/model\"\r\n-\t\"github.com/Coreychen4444/Users/repository\"\r\n-\t\"github.com/dgrijalva/jwt-go\"\r\n-\t\"golang.org/x/crypto/bcrypt\"\r\n-\t\"gorm.io/gorm\"\r\n-)\r\n-\r\n-type UserService struct {\r\n-\tr *repository.DbRepository\r\n-}\r\n-\r\n-func NewUserService(r *repository.DbRepository) *UserService {\r\n-\treturn &UserService{r: r}\r\n-}\r\n-\r\n-// 注册\r\n-func (s *UserService) Register(username, password string) (*model.User, string, error) {\r\n-\t//校验\r\n-\tif len(username) == 0 || len(password) == 0 {\r\n-\t\treturn nil, \"\", errors.New(\"用户名或密码不能为空,请重新输入\")\r\n-\t}\r\n-\tif len(password) < 6 {\r\n-\t\treturn nil, \"\", errors.New(\"密码长度不能小于6位,请重新输入\")\r\n-\t}\r\n-\tif len(username) > 32 || len(password) > 32 {\r\n-\t\treturn nil, \"\", errors.New(\"用户名或密码长度不能超过32位,请重新输入\")\r\n-\t}\r\n-\tuser, err := s.r.GetUserByName(username)\r\n \tif err != nil &&err!=gorm.R{\r\n \t\treturn nil, \"\", err\r\n \t}\r\n \t//判断用户名是否存在\r\n"
                }
            ],
            "date": 1691484401693,
            "name": "Commit-0",
            "content": "// 问题：缺少注释，不易于阅读和维护。\r\npackage service\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n\t\"time\"\r\n\r\n\t\"github.com/Coreychen4444/Users/model\"\r\n\t\"github.com/Coreychen4444/Users/repository\"\r\n\t\"github.com/dgrijalva/jwt-go\"\r\n\t\"golang.org/x/crypto/bcrypt\"\r\n\t\"gorm.io/gorm\"\r\n)\r\n\r\ntype UserService struct {\r\n\tr *repository.DbRepository\r\n}\r\n\r\nfunc NewUserService(r *repository.DbRepository) *UserService {\r\n\treturn &UserService{r: r}\r\n}\r\n\r\n// 注册\r\nfunc (s *UserService) Register(username, password string) (*model.User, string, error) {\r\n\t//校验\r\n\tif len(username) == 0 || len(password) == 0 {\r\n\t\treturn nil, \"\", errors.New(\"用户名或密码不能为空,请重新输入\")\r\n\t}\r\n\tif len(password) < 6 {\r\n\t\treturn nil, \"\", errors.New(\"密码长度不能小于6位,请重新输入\")\r\n\t}\r\n\tif len(username) > 32 || len(password) > 32 {\r\n\t\treturn nil, \"\", errors.New(\"用户名或密码长度不能超过32位,请重新输入\")\r\n\t}\r\n\tuser, err := s.r.GetUserByName(username)\r\n\tif err != nil {\r\n\t\treturn nil, \"\", err\r\n\t}\r\n\t//判断用户名是否存在\r\n\tif user != nil {\r\n\t\treturn nil, \"\", errors.New(\"用户名已存在,请重新输入\")\r\n\t}\r\n\tvar newUser model.User\r\n\t//加密\r\n\thashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\r\n\tif err != nil {\r\n\t\treturn nil, \"\", err\r\n\t}\r\n\tnewUser.Username = username\r\n\tnewUser.PasswordHash = string(hashedPassword)\r\n\t//创建用户\r\n\tuser, err = s.r.CreateUsers(&newUser)\r\n\tif err != nil {\r\n\t\treturn nil, \"\", err\r\n\t}\r\n\ttoken, tknerr := GenerateToken(user.ID)\r\n\tif tknerr != nil {\r\n\t\treturn nil, \"\", fmt.Errorf(\"生成token时出错: %w\", tknerr)\r\n\t}\r\n\treturn user, token, nil\r\n}\r\n\r\n// 登录\r\nfunc (s *UserService) Login(username, password string) (*model.User, string, error) {\r\n\t//校验输入\r\n\tif len(username) == 0 || len(password) == 0 {\r\n\t\treturn nil, \"\", fmt.Errorf(\"用户名或密码不能为空,请重新输入\")\r\n\t}\r\n\tif len(username) > 32 || len(password) > 32 {\r\n\t\treturn nil, \"\", fmt.Errorf(\"用户名或密码长度不能超过32位,请重新输入\")\r\n\t}\r\n\t//查找用户\r\n\tuser, err := s.r.GetUserByName(username)\r\n\tif err != nil {\r\n\t\tif err == gorm.ErrRecordNotFound {\r\n\t\t\treturn nil, \"\", fmt.Errorf(\"用户名不存在,请重新输入\")\r\n\t\t}\r\n\t\treturn nil, \"\", fmt.Errorf(\"查找用户时出错: %w\", err)\r\n\t}\r\n\t//验证密码\r\n\terr = bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password))\r\n\tif err != nil {\r\n\t\tif err == bcrypt.ErrMismatchedHashAndPassword {\r\n\t\t\treturn nil, \"\", fmt.Errorf(\"密码错误,请重新输入\")\r\n\t\t}\r\n\t\treturn nil, \"\", fmt.Errorf(\"验证密码时出错: %w\", err)\r\n\t}\r\n\ttoken, tknerr := GenerateToken(user.ID)\r\n\tif tknerr != nil {\r\n\t\treturn nil, \"\", fmt.Errorf(\"生成token时出错: %w\", tknerr)\r\n\t}\r\n\treturn user, token, nil\r\n}\r\n\r\n// 获取用户信息\r\nfunc (s *UserService) GetUserInfo(id int64, token string) (*model.User, error) {\r\n\t_, err := VerifyToken(token)\r\n\tif err != nil {\r\n\t\treturn nil, fmt.Errorf(\"验证token时出错: %w\", err)\r\n\t}\r\n\tuser, err := s.r.GetUserById(id)\r\n\tif err != nil {\r\n\t\tif err == gorm.ErrRecordNotFound {\r\n\t\t\treturn nil, fmt.Errorf(\"该用户不存在\")\r\n\t\t}\r\n\t\treturn nil, fmt.Errorf(\"查找用户时出错: %w\", err)\r\n\t}\r\n\treturn user, nil\r\n\r\n}\r\n\r\n// 生成和验证token\r\ntype Claims struct {\r\n\tUserID int64\r\n\tjwt.StandardClaims\r\n}\r\n\r\nvar jwtKey = []byte(\"tokenkey\")\r\n\r\n// 生成token\r\nfunc GenerateToken(id int64) (string, error) {\r\n\texpirationTime := time.Now().Add(24 * time.Hour)\r\n\tclaims := &Claims{\r\n\t\tUserID: id,\r\n\t\tStandardClaims: jwt.StandardClaims{\r\n\t\t\tExpiresAt: expirationTime.Unix(),\r\n\t\t},\r\n\t}\r\n\r\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\r\n\treturn token.SignedString(jwtKey)\r\n}\r\n\r\n// 验证token\r\nfunc VerifyToken(tknStr string) (*Claims, error) {\r\n\tclaims := &Claims{}\r\n\ttkn, err := jwt.ParseWithClaims(tknStr, claims, func(token *jwt.Token) (interface{}, error) {\r\n\t\treturn jwtKey, nil\r\n\t})\r\n\r\n\tif err != nil {\r\n\t\tif err == jwt.ErrSignatureInvalid {\r\n\t\t\treturn nil, fmt.Errorf(\"invalid JWT signature\")\r\n\t\t}\r\n\t\treturn nil, fmt.Errorf(\"could not parse JWT token\")\r\n\t}\r\n\r\n\tif !tkn.Valid {\r\n\t\treturn nil, fmt.Errorf(\"invalid JWT token\")\r\n\t}\r\n\r\n\treturn claims, nil\r\n}\r\n"
        }
    ]
}